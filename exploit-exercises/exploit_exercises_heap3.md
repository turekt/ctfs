# Exploit exercises - heap3 challenge

## Vulnerability

Let's immediately dive into the disassembly:

```
void main(undefined4 param_1,int param_2)

{
  char *__dest;
  char *__dest_00;
  char *__dest_01;
  
  __dest = (char *)malloc(0x20);
  __dest_00 = (char *)malloc(0x20);
  __dest_01 = (char *)malloc(0x20);
  strcpy(__dest,*(char **)(param_2 + 4));
  strcpy(__dest_00,*(char **)(param_2 + 8));
  strcpy(__dest_01,*(char **)(param_2 + 0xc));
  free(__dest_01);
  free(__dest_00);
  free(__dest);
  puts("dynamite failed?");
  return;
}
```

Looking into it, we see that this may be exploited in a similar way as heap1 challenge. But the scenario of three adjacent chunks being allocated and freed with a possibility of an overflow into neighbouring chunks reminded me of an old exploit that I was trying to understand at the time - unlink.

I used this challenge to try and understand the old unlink exploit with glibc version which does not have the current security checks.

I won't to go into much detail about unlink exploit but will recap few important points in order to better understand how the solution works. The unlink exploit relies on having the ability to write over malloc_chunk headers in the adjacent chunks and adjusting heap state in a manner that would result in consolidation of two adjacent chunks. When consolidating adjacent chunks, one of the chunks we control gets unlinked with the following code:

```
#define unlink( P, BK, FD ) {          \
  BK = P->bk;                          \
  FD = P->fd;                          \
  FD->bk = BK;                         \
  BK->fd = FD;                         \
}
```

As its known, malloc\_chunk header has forward and backward pointers at offset 8 and 12 from malloc\_chunk header start address. The usage of `->` sign translates to adding the appropriate offset to the malloc\_chunk header start address, which in turn means that unlink translates to:

```
BK = *(P + 12)   // BK = P->bk;
FD = *(P + 8)    // FD = P->fd;
*(FD + 12) = BK  // FD->bk = BK;
*(BK + 8)  = FD  // BK->fd = FD;
```

The above code means that unlink is a classic memory write which can be exploited especially if we can control fd and bk pointer values. In the challenge, we have to redirect the flow by faking a free chunk and set fd and bk pointer values so that they overwrite a puts GOT entry since puts is the last call made in the binary.

## Issuing unlink

### Requirements

In order to issue the unlink, first we have to overflow into the `prev_size` part of the header and set the previous chunk size to be large enough to fall into small or large bin, since fast chunks will not get consolidated. Second, we overflow further into the next chunk's size and unset its `PREV_IN_USE` flag to mark the previous chunk as a free chunk. If we mark the previous chunk as free, when freeing the current chunk, the backward consolidation will be executed, thus giving us the ability for an unlink exploit.

In our case:

```
strcpy(__dest,*(char **)(param_2 + 4));
strcpy(__dest_00,*(char **)(param_2 + 8));
strcpy(__dest_01,*(char **)(param_2 + 0xc));
free(__dest_01);
free(__dest_00);
free(__dest);
```

The chunks are filled from first to last, but freed backwards. Also, there is an additional challenge here - the `strcpy` function will not copy anything after `\x00`, therefore we need to do some kind of a trick to specify `prev_size` and `size` part of the malloc_chunk header without using `\x00`.

### Redirecting flow

We will use the second chunk to overflow into the third, thus issuing unlink on the second chunk. Let's think for a second how a standard free of the third chunk would look (no exploits, standard program execution).

When `free(__dest_01)` is called, at some point, glibc starts checking adjacent chunks whether they are free. When checking if the previous adjacent chunk is free, it will check its `PREV_IN_USE` flag which is in the `size` part of the malloc\_chunk header. This flag needs to be set to 0, meaning that the previous chunk is free and can be merged with the current one. Next step would be to read the `prev_size` part of the malloc\_chunk header (positioned at `size - 4`). The `prev_size` is used as an offset which will set the pointer at `(current address of prev_size) - (prev_size value)`. When the pointer is set at the calculated address, the pointer thinks that he is pointing at the start of the previous chunk. Now, the unlink will commence, executing the already known write:

```
BK = *(P + 12)   // BK = P->bk;
FD = *(P + 8)    // FD = P->fd;
*(FD + 12) = BK  // FD->bk = BK;
*(BK + 8)  = FD  // BK->fd = FD;
```

In standard program execution, FD and BK pointers are set by glibc and are making this chunk a part of a double linked list. The unlink means that the chunk is "detached" from the list by rewriting pointers of the next and previous chunk in the list but using the current chunk as a reference to next and previous chunks.

In our case, we can use a known trick to set the `prev_size` to -8 (`0xfffffff8`) mainly because we cannot use a small number (do not forget about `\x00`) and we do not have access to larger memory addresses in case we want to use a much larger number (e.g. `0x01010101`). Setting the `prev_size` to -8 will make glibc calculate the offset as `(current address of prev_size) - (-8)`, meaning - moving the pointer forward 8 bytes into third chunk's memory content. Since we control third chunk's memory content, we can fake a free chunk, writing our own header with fd and bk pointers. Our fake free chunk will have fd pointer pointing to `(puts got entry) - 12` and bk pointer pointing to our shellcode placed on the heap, we just have to make sure that it is small enough  (less than 8) since there is going to be a write as a last step of the unlink operation (`*(BK + 8) = FD`). First chunk would be a perfect place for this.

Let's look into what we have to do:
```
     chunk __dest -> +------------------------------------+
      header         |  prev_size                         |
                     +------------------------------------+
                     |  size                        |A|M|P|
   __dest content -> +------------------------------------+
                     |                                    |
                     |  shellcode ...                     |
                     |                                    |
                     +------------------------------------+ <-- no overflow here
  chunk __dest_00 -> +------------------------------------+
   header            |  prev_size                         |
                     +------------------------------------+
                     |  size                        |A|M|P|
__dest_00 content -> +------------------------------------+
                     |  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|
                     |AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|
                     |AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|
                     +------------------------------------+ <-- overflow here
  chunk __dest_01 -> +------------------------------------+  
   header            |  \xf8\xff\xff\xff (prev_size)      | <-- -8
                     +------------------------------------+
                     |  \xfc\xff\xff\xff (size)     |0|0|0| <-- PREV_IN_USE = 0
__dest_01 content -> +------------------------------------+
                     |+----------------------------------+<---- faking a free chunk, will get unlinked
                     ||  fake prev_size        (4 bytes) ||
                     |+----------------------------------+|
                     ||  fake size             (4 bytes) ||
                     |+----------------------------------+|
                     ||  fake fd               (4 bytes) |<---- (puts got) - 12
                     |+----------------------------------+|
                     ||  fake bk               (4 bytes) |<---- (dest ptr) + 4
                     |+----------------------------------+|
                     +------------------------------------+
                     
```
- we put our shellcode in first chunk content, has to be small enough since bk will point to it and (bk + 8) will get overwritten with fd
- we overflow the whole second chunk content and start writing in the third chunk's header
  - set `prev_size` to -8 (`0xfffffff8`)
  - set `size` to -4 (`0xfffffffc`) which sets all bits to 1 except for the last three bits (our A|M|P bits will be zeroed out)
- write a fake chunk into third chunk's content
  - header is not relevant for unlinking, put `prev_size` and `size` to anything
  - fd has to point to `(puts got entry) - 12` so that puts GOT entry gets written when `*(FD + 12) = BK  // FD->bk = BK;`
  - bk has to point to our shellcode (first chunk content) and be small enough so it won't get overwritten
  
Also, when setting bk pointer, we will have to add 4 to `__dest` content address because of `free(__dest)` which will zero out the first 4 bytes of first chunk's content. Therefore, when filling the first chunk, we will have to add 4 bytes of junk and then the shellcode. Solution for this challenge is `solve_exploit_exercises_heap3.py`.
  
