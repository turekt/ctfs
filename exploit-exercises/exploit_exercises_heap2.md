# Exploit exercises - heap2 challenge

## Vulnerability

Let's immediately dive into the disassembly:

```
void main(void)

{
  char *pcVar1;
  int iVar2;
  size_t sVar3;
  char local_90 [5];
  char local_8b [2];
  char acStack137 [133];
  
  while( true ) {
    printf("[ auth = %p, service = %p ]\n",auth,service);
    pcVar1 = fgets(local_90,0x80,stdin);
    if (pcVar1 == (char *)0x0) break;
    iVar2 = strncmp(local_90,"auth ",5);
    if (iVar2 == 0) {
      auth = (char *)malloc(4);
      memset(auth,0,4);
      sVar3 = strlen(local_8b);
      if (sVar3 < 0x1f) {
        strcpy(auth,local_8b);
      }
    }
    iVar2 = strncmp(local_90,"reset",5);
    if (iVar2 == 0) {
      free(auth);
    }
    iVar2 = strncmp(local_90,"service",6);
    if (iVar2 == 0) {
      service = strdup(acStack137);
    }
    iVar2 = strncmp(local_90,"login",5);
    if (iVar2 == 0) {
      if (*(int *)(auth + 0x20) == 0) {
        puts("please enter your password");
      }
      else {
        puts("you have logged in already!");
      }
    }
  }
  return;
}
```

We have several actions available here: auth, reset, service and login. By the looks of it, we have to make this binary output the `"you have logged in already!"` string.

Further review shows several important things:
- both auth and service use `malloc` and store their substrings on the heap (`strdup` uses `malloc` under the hood)
- in order to be "logged in" we need to have any non zero value stored at `auth + 0x20`
- auth allocates 4 bytes but reads max 30 (`sVar3 < 0x1f`) which is one less than needed (we need 32, therefore cannot simply overflow)
- service allocates as much as we want (sort of)

With all this in mind, we can simply allocate 4 byte auth memory first and then service memory after that. When we fill the service memory, we just have to write enough data in it to satisfy the `auth + 0x20 != 0` check. Solution for this challenge is `solve_exploit_exercises_heap2.py`
